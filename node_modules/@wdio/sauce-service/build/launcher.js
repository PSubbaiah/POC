"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _perf_hooks = require("perf_hooks");

var _logger = _interopRequireDefault(require("@wdio/logger"));

var _saucelabs = _interopRequireDefault(require("saucelabs"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const SC_RELAY_DEPCRECATION_WARNING = ['The "scRelay" option is depcrecated and will be removed', 'with the upcoming versions of @wdio/sauce-service. Please', 'remove the option as tests should work identically without it.'].join(' ');
const log = (0, _logger.default)('@wdio/sauce-service');

class SauceLauncher {
  constructor(options, capabilities, config) {
    this.options = options;
    this.api = new _saucelabs.default(config);
  }

  async onPrepare(config, capabilities) {
    if (!this.options.sauceConnect) {
      return;
    }

    const sauceConnectOpts = this.options.sauceConnectOpts || {};
    const sauceConnectTunnelIdentifier = sauceConnectOpts.tunnelIdentifier || `SC-tunnel-${Math.random().toString().slice(2)}`;
    this.sauceConnectOpts = _objectSpread({
      noAutodetect: true,
      tunnelIdentifier: sauceConnectTunnelIdentifier
    }, sauceConnectOpts);
    let endpointConfigurations = {};

    if (this.options.scRelay) {
      log.warn(SC_RELAY_DEPCRECATION_WARNING);
      const scRelayPort = this.sauceConnectOpts.port || 4445;
      this.sauceConnectOpts.sePort = scRelayPort;
      endpointConfigurations = {
        protocol: 'http',
        hostname: 'localhost',
        port: scRelayPort
      };
    }

    if (Array.isArray(capabilities)) {
      for (const capability of capabilities) {
        if (!capability['sauce:options']) {
          capability['sauce:options'] = {};
        }

        Object.assign(capability, endpointConfigurations);
        capability['sauce:options'].tunnelIdentifier = capability.tunnelIdentifier || capability['sauce:options'].tunnelIdentifier || sauceConnectTunnelIdentifier;
        delete capability.tunnelIdentifier;
      }
    } else {
      for (const browserName of Object.keys(capabilities)) {
        if (!capabilities[browserName].capabilities['sauce:options']) {
          capabilities[browserName].capabilities['sauce:options'] = {};
        }

        Object.assign(capabilities[browserName].capabilities, endpointConfigurations);
        capabilities[browserName].capabilities['sauce:options'].tunnelIdentifier = capabilities[browserName].capabilities.tunnelIdentifier || capabilities[browserName].capabilities['sauce:options'].tunnelIdentifier || sauceConnectTunnelIdentifier;
        delete capabilities[browserName].capabilities.tunnelIdentifier;
      }
    }

    const obs = new _perf_hooks.PerformanceObserver(list => {
      const entry = list.getEntries()[0];
      log.info(`Sauce Connect successfully started after ${entry.duration}ms`);
    });
    obs.observe({
      entryTypes: ['measure'],
      buffered: false
    });

    _perf_hooks.performance.mark('sauceConnectStart');

    this.sauceConnectProcess = await this.api.startSauceConnect(this.sauceConnectOpts);

    _perf_hooks.performance.mark('sauceConnectEnd');

    _perf_hooks.performance.measure('bootTime', 'sauceConnectStart', 'sauceConnectEnd');
  }

  onComplete() {
    if (!this.sauceConnectProcess) {
      return;
    }

    return this.sauceConnectProcess.close();
  }

}

exports.default = SauceLauncher;